°
This document represents a prioritized list of goals and descriptions, which should be
read from top to bottom.
____________________________________________________________________________________________________________________________

To-do list:

Make new namespace, called DateAndTime
- move all necessary code in here.

Rebuild and test.
- Add test code into DST.Core.Tests
- Change system timezone and re-run tests (convert results to my actual local timezone and compare).
- Be sure to test positive timezones (Base offset UTC+5; DST offset UTC+6)

Commit changes.

[Optional]

Revise all references to AstronomicalDateTime to reference the object by its implementing interface.
- Use is or as operator where ever necessary.

Consider also referencing instances of DateTimeInfo by its interface, IDateTimeInfo

*** Expose all necessary members
*** Might need to replace the static members, or use instance methods to retrieve the static properties.
IDateTimeInfo
- TimeZoneInfo ClientTimeZoneInfo
- ...

DateTimeInfo : IDateTimeInfo
- ...

IDateTime
- DateTime Value
- DateTimeKind Kind
- long Ticks
- IDateTime Date
- TimeSpan Time
- TimeSpan UtcOffset
- long MinTickSpan
- long MaxTickSpan

IClientDateTime : IDateTime
- IDateTimeInfo Info

IAstronomicalDateTime
- GetTicksFromEpoch
- GetEarthRotationAngle
- GetMeanSiderealTime
- GetSiderealTime
- GetEclipticLongitude
- GetMeanSolarLongitude
- GetMeanLunarLongitude
- GetMeanObliquity
- GetNutationInLongitude
- GetNutationInObliquity
- GetEquationOfEquinoxes
- GetEquationOfOrigins

IMutableDateTime
- IMutableDateTime AddSeconds
- IMutableDateTime AddMinutes
- IMutableDateTime AddHours
- IMutableDateTime AddDays
- IMutableDateTime AddWeeks
- IMutableDateTime AddMonths
- IMutableDateTime AddYears
- IMutableDateTime AddTicks
- DateTime ToLocalTime
- DateTime ToStandardTime
- IMutableDateTime FromStandardTime
- bool IsMinOrMaxValue

AstronomicalDateTime : IDateTime, IClientDateTime, IAstronomicalDateTime, IMutableDateTime
- ...

DateTimeFactory
- IDateTime Create(DateTime dateTime, IDateTimeInfo dateTimeInfo)
	_ = dateTimeInfo ?? throw new ArgumentNullException(nameof(dateTimeInfo));
    return new AstronomicalDateTime(dateTime, dateTimeInfo);

LocalTracker
	public ICoordinate[] Track(IDateTime[] dateTimes)
        {
            if (dateTimes is null)
            {
                return Array.Empty<IHorizontalCoordinate>();
            }

            ICoordinate[] positions = new ICoordinate[dateTimes.Length];

            for (int i = 0; i < dateTimes.Length; i++)
            {
				if (dateTimes[i] is IAstronomicalDateTime)
				{
					positions[i] = Track(dateTimes[i]); // LocalTracker.Track(IAstronomicalDateTime dateTime)
				}
				else
				{
					positions[i] = null;
				}
            }

            return positions;
        }

________________________________________________________________________________________________________

Web app project (DST):

** BUG? - IDateTimeAdder and/or ITimeScalable

When adding in seconds, minutes, and hours in sidereal time and stellar time, 
the datetimes are all the same.

This is actually due to the ITimeScalable implementations converting the ticks
to total days, then truncating the fractional part.
	
Since each interval being added is less than a whole day, the value will almost always be 0.

Test a 24 hour period for 1 hour intervals, where each interval is based on the 
starting datetime. Only the last interval will be different, since it is 24 hours
from the start, which is 1 whole day.
Likewise, testing a 168 hour period for 12 hour intervals, every two datetimes are the same.

Solution - To avoid user confusion, only allow tracking in Sidereal/Stellar time if
			tracking in days, weeks, months, and years.
			This will be accomplished in the front-end.

			The user may, however, still choose the Earth-rotational algorithm, 
			but can only track in mean solar time if using seconds, minutes, and hours.

...........

Using Tracker
	Store results in a Dictionary<DateTime, HorizontalCoordinate>, where DateTime is computed by AstronomicalDateTime.ToLocalDateTime()

Implement geo-positioning support
	Resulting object is GeographicCoordinate

Graphing support
	Graph the trajectory of a tracked object as a sinosoidal wave (position over time)

"Continuous" Tracking
	After tracking over time, allow the user to click a button to continue tracking for the same period/interval, 
	but starting at the last DateTime value.

Implement Error Logging (Users report errors; developer looks over report)
	Use a singleton, thread-safe logger class
	Include serialized exception with complete stack-trace.

________________________________________________________________________________________________________