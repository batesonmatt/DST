°
This document represents a prioritized list of goals and descriptions, which should be
read from top to bottom.
____________________________________________________________________________________________________________________________

To-do list:

Will need to revise DateTimeInfo.Min- and MaxUtcDateTime so that they calculate correctly based on the client timezone.
- Use instance methods
- Might need to check whether BaseUtcOffset is less than the DST offset. (postive timezones go forward an hour)
- Consider DateTimeInfo.MinLocalDateTime and .MaxLocalDateTime as Calendar.Min- and MaxSupportedDateTime,
  then use these to check bounds on the standard datetime, convert to UTC, that way GetAdjustedDateTime
  will use Min- or MaxAstronomicalDateTime for bounds-checking.
  OR
  Consider Min- and MaxStandardDateTime by padding the min and max supported values by the BaseUtcOffset.
  This way, when converting to local or standard, we can still go beyond the min and max utc values.

Consider using DateTime.SpecifyKind(DateTime, DateTimeKind)

Consider public static DateTimeKind DateTimeInfo.StandardKind => DateTimeKind.Unspecified
- Use this for the Standard conversions and where necessary.

Consider public DateTimeKind AstronomicalDateTime.Kind => Value.Kind

Revise UnspecifiedKind concept.
- Only use DateTimeKind.Utc and DateTimeKind.Unspecified.
- Don't worry about checking if the kind is unspecified or local, only if it's Utc.
- Consider removing this enum and use DateTimeKind instead as an override when creating a new AstronomicalDateTime.



Rebuild and test.
- Add test code into DST.Core.Tests
- Change system timezone and re-run tests (convert results to my actual local timezone and compare).

Commit changes.

[Optional] Revise all references to AstronomicalDateTime to use IDateTime.
- Use is or as operator where ever necessary.

________________________________________________________________________________________________________

Web app project (DST):

** BUG? - IDateTimeAdder and/or ITimeScalable

When adding in seconds, minutes, and hours in sidereal time and stellar time, 
the datetimes are all the same.

This is actually due to the ITimeScalable implementations converting the ticks
to total days, then truncating the fractional part.
	
Since each interval being added is less than a whole day, the value will almost always be 0.

Test a 24 hour period for 1 hour intervals, where each interval is based on the 
starting datetime. Only the last interval will be different, since it is 24 hours
from the start, which is 1 whole day.
Likewise, testing a 168 hour period for 12 hour intervals, every two datetimes are the same.

Solution - To avoid user confusion, only allow tracking in Sidereal/Stellar time if
			tracking in days, weeks, months, and years.
			This will be accomplished in the front-end.

			The user may, however, still choose the Earth-rotational algorithm, 
			but can only track in mean solar time if using seconds, minutes, and hours.

...........

Using Tracker
	Store results in a Dictionary<DateTime, HorizontalCoordinate>, where DateTime is computed by AstronomicalDateTime.ToLocalDateTime()

Implement geo-positioning support
	Resulting object is GeographicCoordinate

Graphing support
	Graph the trajectory of a tracked object as a sinosoidal wave (position over time)

"Continuous" Tracking
	After tracking over time, allow the user to click a button to continue tracking for the same period/interval, 
	but starting at the last DateTime value.

Implement Error Logging (Users report errors; developer looks over report)
	Use a singleton, thread-safe logger class
	Include serialized exception with complete stack-trace.

________________________________________________________________________________________________________