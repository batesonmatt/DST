<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BearingFormatEast" xml:space="preserve">
    <value>{0}E</value>
    <comment>A geographic bearing indicator denoted by the uppercase letter "E" to be appended to the right-end of the string value (representing some longitudinal angle) at position 0, with no whitespace in between.</comment>
  </data>
  <data name="BearingFormatNorth" xml:space="preserve">
    <value>{0}N</value>
    <comment>A geographic bearing indicator denoted by the uppercase letter "N" to be appended to the right-end of the string value (representing some latitudinal angle) at position 0, with no whitespace in between.</comment>
  </data>
  <data name="BearingFormatSouth" xml:space="preserve">
    <value>{0}S</value>
    <comment>A geographic bearing indicator denoted by the uppercase letter "S" to be appended to the right-end of the string value (representing some latitudinal angle) at position 0, with no whitespace in between.</comment>
  </data>
  <data name="BearingFormatWest" xml:space="preserve">
    <value>{0}W</value>
    <comment>A geographic bearing indicator denoted by the uppercase letter "W" to be appended to the right-end of the string value (representing some longitudinal angle) at position 0, with no whitespace in between.</comment>
  </data>
  <data name="CompactFormatDegrees" xml:space="preserve">
    <value>{0:0}°</value>
    <comment>Rounds the floating-point value at position 0 to the nearest integer, omits the decimal part, and excludes padded zeros. A single digit zero placeholder is used if the numerical value is zero. A degree symbol is appended to the right-end of the resultant string, with no whitespace in between.</comment>
  </data>
  <data name="CompactFormatHours" xml:space="preserve">
    <value>{0:0}h</value>
    <comment>Rounds the floating-point value at position 0 to the nearest integer, omits the decimal part, and excludes padded zeros. A single digit zero placeholder is used if the numerical value is zero. A lowercase letter "h" is appended to the right-end of the resultant string, with no whitespace in between.</comment>
  </data>
  <data name="ComponentFormatDegrees" xml:space="preserve">
    <value>{0:0}°{1:00}'{2:00.###}"</value>
    <comment>The degree-minute-second (DMS) component form of an angle, with the integer degrees at position 0, the integer minutes at position 1, and the total remaining seconds at position 2. Includes fractional seconds, if any, rounded to the nearest one-thousandth. A single digit zero placeholder is used for the degrees component, and a double digit zero placeholder is used for the minutes component and the integer part of the seconds component. A degree symbol, single apostrophe, and double quotation mark appends the degrees, minutes, and seconds components, respectively. No whitespace separates the components.</comment>
  </data>
  <data name="ComponentFormatHours" xml:space="preserve">
    <value>{0:00}h {1:00}m {2:00.###}s</value>
    <comment>The hour-minute-second (HMS) component form of an angle, with the integer hours at position 0, the integer minutes at position 1, and the total remaining seconds at position 2. Includes fractional seconds, if any, rounded to the nearest one-thousandth. A double digit zero placeholder is used for the integer part of each component. A lowercase letter "h", "m", and "s" appends the hours, minutes, and seconds components, respectively. A single whitespace character separates the components.</comment>
  </data>
  <data name="CoordinateFormatNoDelimiter" xml:space="preserve">
    <value>{0} {1}</value>
    <comment>A point-coordinate consisting of a group of two components, with the first component at position 0 and the second component at position 1. Only a single whitespace character separates the components.</comment>
  </data>
  <data name="CoordinateFormatWithDelimiter" xml:space="preserve">
    <value>{0}, {1}</value>
    <comment>A point-coordinate consisting of a group of two components, with the first component at position 0 and the second component at position 1. A left-facing comma and single whitespace character separates the components.</comment>
  </data>
  <data name="DecimalFormatDegrees" xml:space="preserve">
    <value>{0:0.0###}°</value>
    <comment>Rounds the floating-point value at position 0 to four decimal places, and appends the degree symbol to the right-end of the resultant string. A single digit zero placeholder is used for the whole and fractional parts.</comment>
  </data>
  <data name="DecimalFormatHours" xml:space="preserve">
    <value>{0:0.0###}h</value>
    <comment>Rounds the floating-point value at position 0 to four decimal places, and appends the lowercase letter "h" to the right-end of the resultant string. A single digit zero placeholder is used for the whole and fractional parts.</comment>
  </data>
  <data name="SignedFormatNegativeValue" xml:space="preserve">
    <value>-{0}</value>
    <comment>A negative sign "-" to prefix the string value (representing some numerical value) at position 0, with no whitespace in between.</comment>
  </data>
  <data name="SignedFormatPositiveValue" xml:space="preserve">
    <value>+{0}</value>
    <comment>A positive sign "+" to prefix the string value (representing some numerical value) at position 0, with no whitespace in between.</comment>
  </data>
</root>